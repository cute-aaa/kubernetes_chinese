# 将数据注入到应用

## 为容器设置启动时要执行的命令及其参数

本页将展示如何为Kubernetes Pod下的容器设置启动时要执行的命令及其参数。

-   [准备开始](https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/#%e5%87%86%e5%a4%87%e5%bc%80%e5%a7%8b)
-   [创建Pod时为其下的容器设置启动时要执行的命令及其参数](https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/#%e5%88%9b%e5%bb%bapod%e6%97%b6%e4%b8%ba%e5%85%b6%e4%b8%8b%e7%9a%84%e5%ae%b9%e5%99%a8%e8%ae%be%e7%bd%ae%e5%90%af%e5%8a%a8%e6%97%b6%e8%a6%81%e6%89%a7%e8%a1%8c%e7%9a%84%e5%91%bd%e4%bb%a4%e5%8f%8a%e5%85%b6%e5%85%a5%e5%8f%82)
-   [使用环境变量来设置参数](https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/#%e4%bd%bf%e7%94%a8%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e6%9d%a5%e8%ae%be%e7%bd%ae%e5%85%a5%e5%8f%82)
-   [通过shell来执行命令](https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/#%e9%80%9a%e8%bf%87shell%e6%9d%a5%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4)
-   [注意](https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/#%e6%b3%a8%e6%84%8f)
-   [接下来](https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/#%e6%8e%a5%e4%b8%8b%e6%9d%a5)

### 准备开始

一个集群。

### 创建Pod时为其下的容器设置启动时要执行的命令及其参数

创建Pod时，可以为其下的容器设置启动时要执行的命令及其参数。如果要设置命令，就 填写在配置文件的`command`字段下，如果要设置命令的参数，就填写在配置文件的`args`字段下。一旦Pod创建完成，该命令及其参数就无法再进行更改了。

如果在配置文件中设置了容器启动时要执行的命令及其参数，那么容器镜像中自带的命令 与参数将会被覆盖而不再执行。如果配置文件中只是设置了参数，却没有设置其对应的命 令，那么容器镜像中自带的命令会使用该新参数作为其执行时的参数。

本示例中，将创建一个只包含单个容器的Pod。在Pod配置文件中设置了一个命令与两个参数：

[`commands.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/commands.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: command-demo
  labels:
    purpose: demonstrate-command
spec:
  containers:
  - name: command-demo-container
    image: debian
    command: ["printenv"]
    args: ["HOSTNAME", "KUBERNETES_PORT"]
  restartPolicy: OnFailure
```

1.  基于YAML文件创建一个Pod：

    ```shell
    kubectl create -f https://k8s.io/docs/tasks/inject-data-application/commands.yaml
    ```

2.  List the running Pods:

    获取正在运行的 pod

    ```shell
    kubectl get pods
    ```

    查询结果显示在command-demo这个Pod下运行的容器已经启动完成

3.  如果要获取容器启动时执行命令的输出结果，可以通过Pod的日志进行查看

    ```shell
    kubectl logs command-demo
    ```

    日志中显示了HOSTNAME 与KUBERNETES_PORT 这两个环境变量的值：

    ```
    command-demo
    tcp://10.3.240.1:443
    ```

### 使用环境变量来设置参数

在上面的示例中，我们直接将一串字符作为命令的参数。除此之外，我们还可以 将环境变量作为命令的参数。

```yaml
env:
- name: MESSAGE
  value: "hello world"
command: ["/bin/echo"]
args: ["$(MESSAGE)"]
```

这样一来，我们就可以将那些用来设置环境变量的方法应用于设置命令的参数，其 中包括了[ConfigMaps](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/) 与 [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/).

>   **Note:** **注意：** 环境变量需要加上括号，类似于`"$(VAR)"`。这是在`command` 或 `args`字段使用变量的格式要求。

### 通过shell来执行命令

有时候，需要通过shell来执行命令。 例如，命令可能由多个命令组合而成，抑或包含 在一个shell脚本中。这时，就可以通过如下方式在shell中执行命令：

```shell
command: ["/bin/sh"]
args: ["-c", "while true; do echo hello; sleep 10;done"]
```

### 注意

下表给出了Docker 与 Kubernetes中对应的字段名称。

| Description                         | Docker field name | Kubernetes field name |
| :---------------------------------- | :---------------- | :-------------------- |
| The command run by the container    | Entrypoint        | command               |
| The arguments passed to the command | Cmd               | args                  |

如果要覆盖默认的Entrypoint 与 Cmd，需要遵循如下规则：

-   如果在容器配置中没有设置`command` 或者 `args`，那么将使用Docker镜像自带的命 令及其参数。
-   如果在容器配置中只设置了`command`但是没有设置`args`,那么容器启动时只会执行该 命令，Docker镜像中自带的命令及其参数会被忽略。
-   如果在容器配置中只设置了`args`,那么Docker镜像中自带的命令会使用该新参数作为 其执行时的参数。
-   如果在容器配置中同时设置了`command` 与 `args`，那么Docker镜像中自带的命令及 其参数会被忽略。容器启动时只会执行配置中设置的命令，并使用配置中设置的参数作为 命令的参数。

下表涵盖了各类设置场景：

| Image Entrypoint | Image Cmd   | Container command | Container args | Command run      |
| :--------------- | :---------- | :---------------- | :------------- | :--------------- |
| `[/ep-1]`        | `[foo bar]` | <not set>         | <not set>      | `[ep-1 foo bar]` |
| `[/ep-1]`        | `[foo bar]` | `[/ep-2]`         | <not set>      | `[ep-2]`         |
| `[/ep-1]`        | `[foo bar]` | <not set>         | `[zoo boo]`    | `[ep-1 zoo boo]` |
| `[/ep-1]`        | `[foo bar]` | `[/ep-2]`         | `[zoo boo]`    | `[ep-2 zoo boo]` |

### 下一步

-   获取更多资讯可参考 [containers and commands](https://kubernetes.io/docs/user-guide/containers/).
-   获取更多资讯可参考 [configuring pods and containers](https://kubernetes.io/docs/tasks/).
-   获取更多资讯可参考 [running commands in a container](https://kubernetes.io/docs/tasks/debug-application-cluster/get-shell-running-container/).
-   参考 [Container](https://kubernetes.io/docs/api-reference/v1.15/#container-v1-core)





## 为容器设置环境变量

本页将展示如何为kubernetes Pod下的容器设置环境变量。



### 准备工作

一个集群。



### 为容器设置一个环境变量

创建Pod时，可以为其下的容器设置环境变量。通过配置文件的`env`或者`envFrom` 字段来设置环境变量。

本示例中，将创建一个只包含单个容器的Pod。Pod的配置文件中设置环境变量的名称为`DEMO_GREETING`， 其值为`"Hello from the environment"`。下面是Pod的配置文件内容:

[`envars.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/envars.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: envar-demo
  labels:
    purpose: demonstrate-envars
spec:
  containers:
  - name: envar-demo-container
    image: gcr.io/google-samples/node-hello:1.0
    env:
    - name: DEMO_GREETING
      value: "Hello from the environment"
```

1.  基于YAML文件创建一个Pod:

    ```shell
    kubectl create -f https://k8s.io/docs/tasks/inject-data-application/envars.yaml
    ```

2.  获取一下当前正在运行的Pods信息:

    ```shell
    kubectl get pods -l purpose=demonstrate-envars
    ```

    查询结果应为:

    ```log
    NAME            READY     STATUS    RESTARTS   AGE
    envar-demo      1/1       Running   0          9s
    ```

3.  进入该Pod下的容器并打开一个命令终端:

    ```shell
    kubectl exec -it envar-demo -- /bin/bash
    ```

4.  在命令终端中通过执行`printenv`打印出环境变量。

    ```shell
    root@envar-demo:/# printenv
    ```

    打印结果应为:

    ```log
    NODE_VERSION=4.4.2
    EXAMPLE_SERVICE_PORT_8080_TCP_ADDR=10.3.245.237
    HOSTNAME=envar-demo
    ...
    DEMO_GREETING=Hello from the environment
    ```

5.  通过键入`exit`退出命令终端。

### 下一步

-   有关环境变量的更多信息，请参阅[这里](https://kubernetes.io/docs/tasks/configure-pod-container/environment-variable-expose-pod-information/)。
-   有关如何通过环境变量来使用Secret，请参阅[这里](https://kubernetes.io/docs/user-guide/secrets/#using-secrets-as-environment-variables)。
-   关于[EnvVarSource](https://kubernetes.io/docs/api-reference/v1.15/#envvarsource-v1-core)资源的信息





## 通过环境变量将Pod信息呈现给容器

此页面显示了Pod如何使用环境变量把自己的信息呈现给pod中运行的容器。环境变量可以呈现pod的字段和容器字段。

有两种方式可以将Pod和Container字段呈现给运行中的容器： 环境变量 和[DownwardAPIVolumeFiles](https://kubernetes.io/docs/resources-reference/v1.15/#downwardapivolumefile-v1-core). 这两种呈现Pod和Container字段的方式都称为*Downward API*。

-   [准备开始](https://kubernetes.io/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#%e5%87%86%e5%a4%87%e5%bc%80%e5%a7%8b)
-   [Downward API](https://kubernetes.io/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#downward-api)
-   [用Pod字段作为环境变量的值](https://kubernetes.io/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#%e7%94%a8pod%e5%ad%97%e6%ae%b5%e4%bd%9c%e4%b8%ba%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc)
-   [用容器字段作为环境变量的值](https://kubernetes.io/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#%e7%94%a8%e5%ae%b9%e5%99%a8%e5%ad%97%e6%ae%b5%e4%bd%9c%e4%b8%ba%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e7%9a%84%e5%80%bc)
-   [接下来](https://kubernetes.io/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/#%e6%8e%a5%e4%b8%8b%e6%9d%a5)

### 准备开始

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 如果你还没有集群，你可以通过 [Minikube](https://kubernetes.io/docs/getting-started-guides/minikube) 构建一 个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

-   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
-   [Play with Kubernetes](http://labs.play-with-k8s.com/)

To check the version, enter `kubectl version`.

### API

有两种方式可以将Pod和Container字段呈现给运行中的容器：

-   环境变量
-   [DownwardAPIVolumeFiles](https://kubernetes.io/docs/resources-reference/v1.15/#downwardapivolumefile-v1-core)

这两种呈现Pod和Container字段的方式都称为*Downward API*。

### 用Pod字段作为环境变量的值

在这个练习中，你将创建一个包含一个容器的pod。这是该pod的配置文件：

[`dapi-envars-pod.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/dapi-envars-pod.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: dapi-envars-fieldref
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "sh", "-c"]
      args:
      - while true; do
          echo -en '\n';
          printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE;
          printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT;
          sleep 10;
        done;
      env:
        - name: MY_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: MY_POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: MY_POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: MY_POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: MY_POD_SERVICE_ACCOUNT
          valueFrom:
            fieldRef:
              fieldPath: spec.serviceAccountName
  restartPolicy: Never
```

这个配置文件中，你可以看到五个环境变量。`env`字段是一个[EnvVars](https://kubernetes.io/docs/resources-reference/v1.15/#envvar-v1-core)类型的数组。 数组中第一个元素指定`MY_NODE_NAME`这个环境变量从Pod的`spec.nodeName`字段获取变量值。同样，其它环境变量也是从Pod的字段获取它们的变量值。

>   **Note:** **注意:** 本示例中的字段是Pod字段，不是Pod中容器的字段。

创建Pod：

```shell
kubectl create -f https://k8s.io/cn/docs/tasks/inject-data-application/dapi-envars-pod.yaml
```

验证Pod中的容器运行正常：

```
kubectl get pods
```

查看容器日志：

```
kubectl logs dapi-envars-fieldref
```

输出信息显示了所选择的环境变量的值：

```
minikube
dapi-envars-fieldref
default
172.17.0.4
default
```

要了解为什么这些值在日志中，请查看配置文件中的`command` 和 `args`字段。 当容器启动时，它将五个环境变量的值写入stdout。每十秒重复执行一次。

接下来，进入Pod中运行的容器，打开一个shell：

```
kubectl exec -it dapi-envars-fieldref -- sh
```

在shell中，查看环境变量：

```
/# printenv
```

输出信息显示环境变量已经指定为Pod的字段的值。

```
MY_POD_SERVICE_ACCOUNT=default
...
MY_POD_NAMESPACE=default
MY_POD_IP=172.17.0.4
...
MY_NODE_NAME=minikube
...
MY_POD_NAME=dapi-envars-fieldref
```

### 用容器字段作为环境变量的值

前面的练习中，你将Pod字段作为环境变量的值。接下来这个练习，你将用容器字段作为环境变量的值。这里是包含一个容器的pod的配置文件：

[`dapi-envars-container.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/dapi-envars-container.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: dapi-envars-resourcefieldref
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox:1.24
      command: [ "sh", "-c"]
      args:
      - while true; do
          echo -en '\n';
          printenv MY_CPU_REQUEST MY_CPU_LIMIT;
          printenv MY_MEM_REQUEST MY_MEM_LIMIT;
          sleep 10;
        done;
      resources:
        requests:
          memory: "32Mi"
          cpu: "125m"
        limits:
          memory: "64Mi"
          cpu: "250m"
      env:
        - name: MY_CPU_REQUEST
          valueFrom:
            resourceFieldRef:
              containerName: test-container
              resource: requests.cpu
        - name: MY_CPU_LIMIT
          valueFrom:
            resourceFieldRef:
              containerName: test-container
              resource: limits.cpu
        - name: MY_MEM_REQUEST
          valueFrom:
            resourceFieldRef:
              containerName: test-container
              resource: requests.memory
        - name: MY_MEM_LIMIT
          valueFrom:
            resourceFieldRef:
              containerName: test-container
              resource: limits.memory
  restartPolicy: Never
```

这个配置文件中，你可以看到四个环境变量。`env`字段是一个[EnvVars](https://kubernetes.io/docs/resources-reference/v1.15/#envvar-v1-core) 类型的数组。数组中第一个元素指定`MY_CPU_REQUEST`这个环境变量从容器的`requests.cpu`字段获取变量值。同样，其它环境变量也是从容器的字段获取它们的变量值。

创建Pod：

```shell
kubectl create -f https://k8s.io/cn/docs/tasks/inject-data-application/dapi-envars-container.yaml
```

验证Pod中的容器运行正常：

```shell
kubectl get pods
```

查看容器日志：

```shell
kubectl logs dapi-envars-resourcefieldref
```

输出信息显示了所选择的环境变量的值：

```
1
1
33554432
67108864
```

### 接下来

-   [给容器定义环境变量](https://kubernetes.io/docs/tasks/configure-pod-container/define-environment-variable-container/)
-   [PodSpec](https://kubernetes.io/docs/resources-reference/v1.15/#podspec-v1-core)
-   [Container](https://kubernetes.io/docs/resources-reference/v1.15/#container-v1-core)
-   [EnvVar](https://kubernetes.io/docs/resources-reference/v1.15/#envvar-v1-core)
-   [EnvVarSource](https://kubernetes.io/docs/resources-reference/v1.15/#envvarsource-v1-core)
-   [ObjectFieldSelector](https://kubernetes.io/docs/resources-reference/v1.15/#objectfieldselector-v1-core)
-   [ResourceFieldSelector](https://kubernetes.io/docs/resources-reference/v1.15/#resourcefieldselector-v1-core)





## 通过文件将Pod信息呈现给容器

此页面描述Pod如何使用DownwardAPIVolumeFile把自己的信息呈现给pod中运行的容器。DownwardAPIVolumeFile可以呈现pod的字段和容器字段。

### 准备工作

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 如果你还没有集群，你可以通过 [Minikube](https://kubernetes.io/docs/getting-started-guides/minikube) 构建一 个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

-   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
-   [Play with Kubernetes](http://labs.play-with-k8s.com/)

To check the version, enter `kubectl version`.

### API

有两种方式可以将Pod和Container字段呈现给运行中的容器：

-   [环境变量](https://kubernetes.io/docs/tasks/configure-pod-container/environment-variable-expose-pod-information/)
-   DownwardAPIVolumeFile

这两种呈现Pod和Container字段的方式都称为*Downward API*。

### 存储Pod字段

在这个练习中，你将创建一个包含一个容器的pod。这是该pod的配置文件：

[`dapi-volume.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/dapi-volume.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubernetes-downwardapi-volume-example
  labels:
    zone: us-est-coast
    cluster: test-cluster1
    rack: rack-22
  annotations:
    build: two
    builder: john-doe
spec:
  containers:
    - name: client-container
      image: k8s.gcr.io/busybox
      command: ["sh", "-c"]
      args:
      - while true; do
          if [[ -e /etc/podinfo/labels ]]; then
            echo -en '\n\n'; cat /etc/podinfo/labels; fi;
          if [[ -e /etc/podinfo/annotations ]]; then
            echo -en '\n\n'; cat /etc/podinfo/annotations; fi;
          sleep 5;
        done;
      volumeMounts:
        - name: podinfo
          mountPath: /etc/podinfo
          readOnly: false
  volumes:
    - name: podinfo
      downwardAPI:
        items:
          - path: "labels"
            fieldRef:
              fieldPath: metadata.labels
          - path: "annotations"
            fieldRef:
              fieldPath: metadata.annotations
```

在配置文件中，你可以看到Pod有一个`downwardAPI`类型的Volume，并且挂载到容器中的`/etc`。

查看`downwardAPI`下面的`items`数组。每个数组元素都是一个[DownwardAPIVolumeFile](https://kubernetes.io/docs/resources-reference/v1.15/#downwardapivolumefile-v1-core)。 第一个元素指示Pod的`metadata.labels`字段的值保存在名为`labels`的文件中。 第二个元素指示Pod的`annotations`字段的值保存在名为`annotations`的文件中。

>   **Note:** **注意:** 本示例中的字段是Pod字段，不是Pod中容器的字段。

创建 Pod：

```shell
kubectl create -f https://k8s.io/cn/docs/tasks/inject-data-application/dapi-volume.yaml
```

验证Pod中的容器运行正常：

```shell
kubectl get pods
```

查看容器的日志：

```shell
kubectl logs kubernetes-downwardapi-volume-example
```

输出显示 `labels` 和 `annotations` 文件的内容：

```shell
cluster="test-cluster1"
rack="rack-22"
zone="us-est-coast"

build="two"
builder="john-doe"
```

进入Pod中运行的容器，打开一个shell：

```
kubectl exec -it kubernetes-downwardapi-volume-example -- sh
```

在该shell中，查看`labels`文件：

```shell
/# cat /etc/labels
```

输出显示Pod的所有labels都已写入`labels`文件。

```shell
cluster="test-cluster1"
rack="rack-22"
zone="us-est-coast"
```

同样，查看`annotations`文件：

```shell
/# cat /etc/annotations
```

查看`/etc`目录下的文件：

```shell
/# ls -laR /etc
```

在输出中可以看到，`labels` 和 `annotations`文件都在一个临时子目录中：这个例子，`..2982_06_02_21_47_53.299460680`。在`/etc`目录中，`..data`是一个指向临时子目录 的符号链接。`/etc`目录中，`labels` 和 `annotations`也是符号链接。

```
drwxr-xr-x  ... Feb 6 21:47 ..2982_06_02_21_47_53.299460680
lrwxrwxrwx  ... Feb 6 21:47 ..data -> ..2982_06_02_21_47_53.299460680
lrwxrwxrwx  ... Feb 6 21:47 annotations -> ..data/annotations
lrwxrwxrwx  ... Feb 6 21:47 labels -> ..data/labels

/etc/..2982_06_02_21_47_53.299460680:
total 8
-rw-r--r--  ... Feb  6 21:47 annotations
-rw-r--r--  ... Feb  6 21:47 labels
```

用符号链接可实现元数据的动态原子刷新；更新将写入一个新的临时目录，然后`..data`符号链接完成原子更新，通过使用[rename(2)](http://man7.org/linux/man-pages/man2/rename.2.html)。

退出shell：

```shell
/# exit
```

### 存储容器字段

前面的练习中，你将Pod字段保存到DownwardAPIVolumeFile中。接下来这个练习，你将存储容器字段。这里是包含一个容器的pod的配置文件：

[`dapi-volume-resources.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/dapi-volume-resources.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubernetes-downwardapi-volume-example-2
spec:
  containers:
    - name: client-container
      image: k8s.gcr.io/busybox:1.24
      command: ["sh", "-c"]
      args:
      - while true; do
          echo -en '\n';
          if [[ -e /etc/podinfo/cpu_limit ]]; then
            echo -en '\n'; cat /etc/podinfo/cpu_limit; fi;
          if [[ -e /etc/cpu_request ]]; then
            echo -en '\n'; cat /etc/podinfo/cpu_request; fi;
          if [[ -e /etc/mem_limit ]]; then
            echo -en '\n'; cat /etc/podinfo/mem_limit; fi;
          if [[ -e /etc/mem_request ]]; then
            echo -en '\n'; cat /etc/podinfo/mem_request; fi;
          sleep 5;
        done;
      resources:
        requests:
          memory: "32Mi"
          cpu: "125m"
        limits:
          memory: "64Mi"
          cpu: "250m"
      volumeMounts:
        - name: podinfo
          mountPath: /etc/podinfo
          readOnly: false
  volumes:
    - name: podinfo
      downwardAPI:
        items:
          - path: "cpu_limit"
            resourceFieldRef:
              containerName: client-container
              resource: limits.cpu
          - path: "cpu_request"
            resourceFieldRef:
              containerName: client-container
              resource: requests.cpu
          - path: "mem_limit"
            resourceFieldRef:
              containerName: client-container
              resource: limits.memory
          - path: "mem_request"
            resourceFieldRef:
              containerName: client-container
              resource: requests.memory
```

在这个配置文件中，你可以看到Pod有一个`downwardAPI`类型的Volume,并且挂载到容器的`/etc`目录。

查看`downwardAPI`下面的`items`数组。每个数组元素都是一个DownwardAPIVolumeFile。

第一个元素指定名为`client-container`的容器中`limits.cpu`字段的值应保存在名为`cpu_limit`的文件中。

创建Pod：

```shell
kubectl create -f https://k8s.io/cn/docs/tasks/inject-data-application/dapi-volume-resources.yaml
```

进入Pod中运行的容器，打开一个shell：

```
kubectl exec -it kubernetes-downwardapi-volume-example-2 -- sh
```

在shell中，查看`cpu_limit`文件：

```shell
/# cat /etc/cpu_limit
```

你可以使用同样的命令查看`cpu_request`, `mem_limit` 和`mem_request` 文件.

### Downward API的功能

下面这些信息可以通过环境变量和DownwardAPIVolumeFiles提供给容器：

能通过`fieldRef`获得的： * `metadata.name` - Pod名称 * `metadata.namespace` - Pod名字空间 * `metadata.uid` - Pod的UID, 版本要求 v1.8.0-alpha.2 * `metadata.labels['<KEY>']` - 单个 pod 标签值 `<KEY>` (例如, `metadata.labels['mylabel']`); 版本要求 Kubernetes 1.9+ * `metadata.annotations['<KEY>']` - 单个 pod 的标注值 `<KEY>` (例如, `metadata.annotations['myannotation']`); 版本要求 Kubernetes 1.9+

能通过`resourceFieldRef`获得的： * 容器的CPU约束值 * 容器的CPU请求值 * 容器的内存约束值 * 容器的内存请求值 * 容器的临时存储约束值, 版本要求 v1.8.0-beta.0 * 容器的临时存储请求值, 版本要求 v1.8.0-beta.0

此外，以下信息可通过DownwardAPIVolumeFiles从`fieldRef`获得：

-   `metadata.labels` - all of the pod’s labels, formatted as `label-key="escaped-label-value"` with one label per line
-   `metadata.annotations` - all of the pod’s annotations, formatted as `annotation-key="escaped-annotation-value"` with one annotation per line
-   `metadata.labels` - 所有Pod的标签，以`label-key="escaped-label-value"`格式显示，每行显示一个label
-   `metadata.annotations` - Pod的注释，以`annotation-key="escaped-annotation-value"`格式显示，每行显示一个标签

以下信息可通过环境变量从`fieldRef`获得：

-   `status.podIP` - 节点IP
-   `spec.serviceAccountName` - Pod服务帐号名称, 版本要求 v1.4.0-alpha.3
-   `spec.nodeName` - 节点名称, 版本要求 v1.4.0-alpha.3
-   `status.hostIP` - 节点IP, 版本要求 v1.7.0-alpha.1

>   **Note:** 如果容器未指定CPU和memory limits，则Downward API默认为节点可分配值。

### 投射密钥到指定路径并且指定文件权限

你可以将密钥投射到指定路径并且指定每个文件的访问权限。更多信息，请参阅[Secrets](https://kubernetes.io/docs/concepts/configuration/secret/).

### Downward API的动机

对于容器来说，有时候拥有自己的信息是很有用的，可避免与Kubernetes过度耦合。Downward API使得容器使用自己或者集群的信息，而不必通过Kubernetes客户端或API服务器。

一个例子是有一个现有的应用假定要用一个非常熟悉的环境变量来保存一个唯一标识。一种可能是给应用增加处理层，但这样是冗余和易出错的，而且它违反了低耦合的目标。更好的选择是使用Pod名称作为标识，把Pod名称注入这个环境变量中。

### 下一步

-   [PodSpec](https://kubernetes.io/docs/resources-reference/v1.15/#podspec-v1-core)
-   [Volume](https://kubernetes.io/docs/resources-reference/v1.15/#volume-v1-core)
-   [DownwardAPIVolumeSource](https://kubernetes.io/docs/resources-reference/v1.15/#downwardapivolumesource-v1-core)
-   [DownwardAPIVolumeFile](https://kubernetes.io/docs/resources-reference/v1.15/#downwardapivolumefile-v1-core)
-   [ResourceFieldSelector](https://kubernetes.io/docs/resources-reference/v1.15/#resourcefieldselector-v1-core)





## 使用 Secret 安全地分发凭证

本文展示如何安全地将敏感数据（如密码和加密密钥）注入到 Pods 中。

### 准备开始

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 如果你还没有集群，你可以通过 [Minikube](https://kubernetes.io/docs/getting-started-guides/minikube) 构建一 个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

-   [Katacoda](https://www.katacoda.com/courses/kubernetes/playground)
-   [Play with Kubernetes](http://labs.play-with-k8s.com/)

To check the version, enter `kubectl version`.

### 将 secret 数据转换为 base-64 形式

假设用户想要有两条 secret 数据：用户名 `my-app` 和密码 `39528$vdg7Jb`。 首先使用 [Base64 编码](https://www.base64encode.org/) 将用户名和密码转化为 base-64 形式。 这里是一个 Linux 示例：

```
​```shell
echo -n 'my-app' | base64
echo -n '39528$vdg7Jb' | base64
​```
```

结果显示 base-64 形式的用户名为 `bXktYXBw`， base-64 形式的密码为 `Mzk1MjgkdmRnN0pi`。

### 创建 Secret

这里是一个配置文件，可以用来创建存有用户名和密码的 Secret:

[`pods/inject/secret.yaml`](https://raw.githubusercontent.com/kubernetes/website/master/content/zh/examples/pods/inject/secret.yaml)

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: test-secret
data:
  username: bXktYXBwCg==
  password: Mzk1MjgkdmRnN0piCg==
```

1.  创建 Secret

    ```shell
    kubectl create -f https://k8s.io/examples/pods/inject/secret.yaml
    ```

    >   **Note:** **注意：** 如果想要跳过 Base64 编码的步骤，可以使用 `kubectl create secret` 命令来创建 Secret：

    ```shell
    kubectl create secret generic test-secret --from-literal=username='my-app' --from-literal=password='39528$vdg7Jb'
    ```

2.  查看 Secret 相关信息：

    kubectl get secret test-secret

    输出：

    ```shell
    NAME          TYPE      DATA      AGE
    test-secret   Opaque    2         1m
    ```

3.  查看 Secret 相关的更多详细信息：

    kubectl describe secret test-secret

    输出：

    ```shell
    Name:       test-secret
    Namespace:  default
    Labels:     <none>
    Annotations:    <none>
    
    Type:   Opaque
    
    Data
    ====
    password:   13 bytes
    username:   7  bytes
    ```

### 创建可以通过卷访问 secret 数据的 Pod

这里是一个可以用来创建 pod 的配置文件：

[`pods/inject/secret-pod.yaml`](https://raw.githubusercontent.com/kubernetes/website/master/content/zh/examples/pods/inject/secret-pod.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: secret-test-pod
spec:
  containers:
    - name: test-container
      image: nginx
      volumeMounts:
          # name must match the volume name below
          - name: secret-volume
            mountPath: /etc/secret-volume
  # The secret data is exposed to Containers in the Pod through a Volume.
  volumes:
    - name: secret-volume
      secret:
        secretName: test-secret
```

1.  创建 Pod：

    ```shell
    kubectl create -f secret-pod.yaml
    ```

2.  确认 Pod 正在运行：

    ```shell
    kubectl get pod secret-test-pod
    ```

    输出：

    ```shell
    NAME              READY     STATUS    RESTARTS   AGE
    secret-test-pod   1/1       Running   0          42m
    ```

3.  在 Pod 中运行的容器中获取一个 shell：

    ```shell
    kubectl exec -it secret-test-pod -- /bin/bash
    ```

4.  secret 数据通过挂载在 `/etc/secret-volume` 目录下的卷暴露在容器中。 在 shell 中，进入 secret 数据被暴露的目录：

    ```shell
    root@secret-test-pod:/# cd /etc/secret-volume
    ```

5.  在 shell 中，列出 `/etc/secret-volume` 目录的文件：

    ```shell
    root@secret-test-pod:/etc/secret-volume# ls
    ```

    输出显示了两个文件，每个对应一条 secret 数据：

    ```shell
    password username
    ```

6.  在 shell 中，显示 `username` 和 `password` 文件的内容：

    ```shell
    root@secret-test-pod:/etc/secret-volume# cat username; echo; cat password; echo
    ```

    输出为用户名和密码：

    ```shell
    my-app
    39528$vdg7Jb
    ```

### 创建通过环境变量访问 secret 数据的 Pod

这里是一个可以用来创建 pod 的配置文件：

[`pods/inject/secret-envars-pod.yaml`](https://raw.githubusercontent.com/kubernetes/website/master/content/zh/examples/pods/inject/secret-envars-pod.yaml)

```
`apiVersion: v1 kind: Pod metadata:   name: secret-envars-test-pod spec:   containers:   - name: envars-test-container     image: nginx     env:     - name: SECRET_USERNAME       valueFrom:         secretKeyRef:           name: test-secret           key: username     - name: SECRET_PASSWORD       valueFrom:         secretKeyRef:           name: test-secret           key: password `
```

1.  创建 Pod：

    ```shell
    kubectl create -f https://k8s.io/examples/pods/inject/secret-envars-pod.yaml
    ```

2.  确认 Pod 正在运行：

    ```shell
    kubectl get pod secret-envars-test-pod
    ```

    输出：

    ```shell
    NAME                     READY     STATUS    RESTARTS   AGE
    secret-envars-test-pod   1/1       Running   0          4m
    ```

3.  在 Pod 中运行的容器中获取一个 shell：

    ```shell
    kubectl exec -it secret-envars-test-pod -- /bin/bash
    ```

4.  在 shell 中，显示环境变量：

    ```shell
    root@secret-envars-test-pod:/# printenv
    ```

    输出包括用户名和密码：

    ```shell
    ...
    SECRET_USERNAME=my-app
    ...
    SECRET_PASSWORD=39528$vdg7Jb
    ```

### 接下来

-   了解更多关于 [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)。
-   了解 [Volumes](https://kubernetes.io/docs/concepts/storage/volumes/)。

### 参考

-   [Secret](https://kubernetes.io/docs/api-reference/v1.15/#secret-v1-core)
-   [Volume](https://kubernetes.io/docs/api-reference/v1.15/#volume-v1-core)
-   [Pod](https://kubernetes.io/docs/api-reference/v1.15/#pod-v1-core)





## 使用 PodPreset 将信息注入 Pods

在 pod 创建时，用户可以使用 `podpreset` 对象将 secrets、卷挂载和环境变量等信息注入其中。 本文展示了一些 `PodPreset` 资源使用的示例。 用户可以从[理解 Pod Presets](https://kubernetes.io/docs/concepts/workloads/pods/podpreset/) 中了解 PodPresets 的整体情况。

### 创建 Pod Preset

#### 简单的 Pod Spec 示例

这里是一个简单的示例，展示了如何通过 Pod Preset 修改 Pod spec 。

**用户提交的 pod spec：**

**[`podpreset-pod.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-pod.yaml)**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: website
  labels:
    app: website
    role: frontend
spec:
  containers:
    - name: website
      image: ecorp/website
      ports:
        - containerPort: 80
```

**Pod Preset 示例：**

[`podpreset-preset.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-preset.yaml)

```yaml
apiVersion: settings.k8s.io/v1alpha1
kind: PodPreset
metadata:
  name: allow-database
  namespace: myns
spec:
  selector:
    matchLabels:
      role: frontend
  env:
    - name: DB_PORT
      value: "6379"
  volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
    - name: cache-volume
      emptyDir: {}
```

**允许进入控制器后的 Pod spec：**

[`podpreset-merged.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-merged.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: website
  labels:
    app: website
    role: frontend
  annotations:
    podpreset.admission.kubernetes.io/podpreset-allow-database: "resource version"
spec:
  containers:
    - name: website
      image: ecorp/website
      volumeMounts:
        - mountPath: /cache
          name: cache-volume
      ports:
        - containerPort: 80
      env:
        - name: DB_PORT
          value: "6379"
  volumes:
    - name: cache-volume
      emptyDir: {}
```

#### 带有 `ConfigMap` 的 Pod Spec 示例

这里的示例展示了如何通过 Pod Preset 修改 Pod spec，Pod Preset 中定义了 `ConfigMap` 作为环境变量取值来源。

**用户提交的 pod spec：**

[`podpreset-pod.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-pod.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: website
  labels:
    app: website
    role: frontend
spec:
  containers:
    - name: website
      image: ecorp/website
      ports:
        - containerPort: 80
```

**用户提交的 ConfigMap：**

[`podpreset-configmap.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-configmap.yaml)

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: etcd-env-config
data:
  number_of_members: "1"
  initial_cluster_state: new
  initial_cluster_token: DUMMY_ETCD_INITIAL_CLUSTER_TOKEN
  discovery_token: DUMMY_ETCD_DISCOVERY_TOKEN
  discovery_url: http://etcd_discovery:2379
  etcdctl_peers: http://etcd:2379
  duplicate_key: FROM_CONFIG_MAP
  REPLACE_ME: "a value"
```

**Pod Preset 示例：**

[`podpreset-allow-db.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-allow-db.yaml)

```yaml
apiVersion: settings.k8s.io/v1alpha1
kind: PodPreset
metadata:
  name: allow-database
  namespace: myns
spec:
  selector:
    matchLabels:
      role: frontend
  env:
    - name: DB_PORT
      value: 6379
    - name: duplicate_key
      value: FROM_ENV
    - name: expansion
      value: $(REPLACE_ME)
  envFrom:
    - configMapRef:
        name: etcd-env-config
  volumeMounts:
    - mountPath: /cache
      name: cache-volume
    - mountPath: /etc/app/config.json
      readOnly: true
      name: secret-volume
  volumes:
    - name: cache-volume
      emptyDir: {}
    - name: secret-volume
      secret:
         secretName: config-details
```

**通过准入控制器后的 Pod spec：**

[`podpreset-allow-db-merged.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-allow-db-merged.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: website
  labels:
    app: website
    role: frontend
  annotations:
    podpreset.admission.kubernetes.io/podpreset-allow-database: "resource version"
spec:
  containers:
    - name: website
      image: ecorp/website
      volumeMounts:
        - mountPath: /cache
          name: cache-volume
        - mountPath: /etc/app/config.json
          readOnly: true
          name: secret-volume
      ports:
        - containerPort: 80
      env:
        - name: DB_PORT
          value: "6379"
        - name: duplicate_key
          value: FROM_ENV
        - name: expansion
          value: $(REPLACE_ME)
      envFrom:
        - configMapRef:
          name: etcd-env-config
  volumes:
    - name: cache-volume
      emptyDir: {}
    - name: secret-volume
      secret:
         secretName: config-details
```

#### 带有 Pod Spec 的 ReplicaSet 示例

以下示例展示了（通过 ReplicaSet 创建 pod 后）只有 pod spec 会被 Pod Preset 所修改。

**用户提交的 ReplicaSet：**

[`podpreset-replicaset.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-replicaset.yaml)

```yaml
apiVersion: apps/v1beta2
kind: ReplicaSet
metadata:
  name: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
    matchExpressions:
      - {key: tier, operator: In, values: [frontend]}
  template:
    metadata:
      labels:
        app: guestbook
        tier: frontend
    spec:
      containers:
      - name: php-redis
        image: gcr.io/google_samples/gb-frontend:v3
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
        env:
          - name: GET_HOSTS_FROM
            value: dns
        ports:
          - containerPort: 80
```

**Pod Preset 示例：**

[`podpreset-preset.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-preset.yaml)

```yaml
apiVersion: settings.k8s.io/v1alpha1
kind: PodPreset
metadata:
  name: allow-database
  namespace: myns
spec:
  selector:
    matchLabels:
      role: frontend
  env:
    - name: DB_PORT
      value: "6379"
  volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
    - name: cache-volume
      emptyDir: {}
```

**通过准入控制器后的 Pod spec：**

注意 ReplicaSet spec 没有改变，用户必须检查单独的 pod 来验证 PodPreset 已被应用。

[`podpreset-replicaset-merged.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-replicaset-merged.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: guestbook
    tier: frontend
  annotations:
    podpreset.admission.kubernetes.io/podpreset-allow-database: "resource version"
spec:
  containers:
  - name: php-redis
    image: gcr.io/google_samples/gb-frontend:v3
    resources:
      requests:
        cpu: 100m
        memory: 100Mi
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
    env:
    - name: GET_HOSTS_FROM
      value: dns
    - name: DB_PORT
      value: "6379"
    ports:
    - containerPort: 80
  volumes:
  - name: cache-volume
    emptyDir: {}
```

#### 多 PodPreset 示例

这里的示例展示了如何通过多个 Pod 注入策略修改 Pod spec。

**用户提交的 pod spec：**

[`podpreset-pod.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-pod.yaml) 

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: website
  labels:
    app: website
    role: frontend
spec:
  containers:
    - name: website
      image: ecorp/website
      ports:
        - containerPort: 80
```

**Pod Preset 示例：**

[`podpreset-preset.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-preset.yaml)

```yaml
apiVersion: settings.k8s.io/v1alpha1
kind: PodPreset
metadata:
  name: allow-database
  namespace: myns
spec:
  selector:
    matchLabels:
      role: frontend
  env:
    - name: DB_PORT
      value: "6379"
  volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
    - name: cache-volume
      emptyDir: {}
```

**另一个 Pod Preset 示例：**

[`podpreset-proxy.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-proxy.yaml)

```yaml
apiVersion: settings.k8s.io/v1alpha1
kind: PodPreset
metadata:
  name: proxy
  namespace: myns
spec:
  selector:
    matchLabels:
      role: frontend
  volumeMounts:
    - mountPath: /etc/proxy/configs
      name: proxy-volume
  volumes:
    - name: proxy-volume
      emptyDir: {}
```

**通过准入控制器后的 Pod spec：**

[`podpreset-multi-merged.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-multi-merged.yaml) 

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: website
  labels:
    app: website
    role: frontend
  annotations:
    podpreset.admission.kubernetes.io/podpreset-allow-database: "resource version"
    podpreset.admission.kubernetes.io/podpreset-proxy: "resource version"
spec:
  containers:
    - name: website
      image: ecorp/website
      volumeMounts:
        - mountPath: /cache
          name: cache-volume
        - mountPath: /etc/proxy/configs
          name: proxy-volume
      ports:
        - containerPort: 80
      env:
        - name: DB_PORT
          value: "6379"
  volumes:
    - name: cache-volume
      emptyDir: {}
    - name: proxy-volume
      emptyDir: {}
```

#### 冲突示例

这里的示例展示了 Pod Preset 与原 Pod 存在冲突时，Pod spec 不会被修改。

**用户提交的 pod spec：**

[`podpreset-conflict-pod.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-conflict-pod.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: website
  labels:
    app: website
    role: frontend
spec:
  containers:
    - name: website
      image: ecorp/website
      volumeMounts:
        - mountPath: /cache
          name: cache-volume
      ports:
  volumes:
    - name: cache-volume
      emptyDir: {}
        - containerPort: 80
```

**Pod Preset 示例：**

[`podpreset-conflict-preset.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-conflict-preset.yaml)

```yaml
apiVersion: settings.k8s.io/v1alpha1
kind: PodPreset
metadata:
  name: allow-database
  namespace: myns
spec:
  selector:
    matchLabels:
      role: frontend
  env:
    - name: DB_PORT
      value: "6379"
  volumeMounts:
    - mountPath: /cache
      name: other-volume
  volumes:
    - name: other-volume
      emptyDir: {}
```

**因存在冲突，通过准入控制器后的 Pod spec 不会改变：**

[`podpreset-conflict-pod.yaml docs/tasks/inject-data-application`](https://github.com/kubernetes/website/blob/master/content/zh/docs/tasks/inject-data-application/podpreset-conflict-pod.yaml)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: website
  labels:
    app: website
    role: frontend
spec:
  containers:
    - name: website
      image: ecorp/website
      volumeMounts:
        - mountPath: /cache
          name: cache-volume
      ports:
  volumes:
    - name: cache-volume
      emptyDir: {}
        - containerPort: 80
```

**如果运行 kubectl describe... 用户会看到以下事件：**

```
$ kubectl describe ...
....
Events:
  FirstSeen             LastSeen            Count   From                    SubobjectPath               Reason      Message
  Tue, 07 Feb 2017 16:56:12 -0700   Tue, 07 Feb 2017 16:56:12 -0700 1   {podpreset.admission.kubernetes.io/podpreset-allow-database }    conflict  Conflict on pod preset. Duplicate mountPath /cache.
```

### 删除 Pod Preset

一旦用户不再需要 pod preset，可以使用 `kubectl` 进行删除：

```shell
$ kubectl delete podpreset allow-database
podpreset "allow-database" deleted
```

